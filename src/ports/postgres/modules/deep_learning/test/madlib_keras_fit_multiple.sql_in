m4_include(`SQLCommon.m4')
m4_changequote(<<<,>>>)
m4_ifdef(<<<__POSTGRESQL__>>>, -- Skip all fit multiple tests for postgres
,<<<
m4_changequote(<!,!>)

-- =================== Setup & Initialization for FitMultiple tests ========================
--
--  For fit multiple, we test end-to-end functionality along with performance elsewhere.
--  They take a long time to run.  Including similar tests here would probably not be worth
--  the extra time added to dev-check.
--
--  Instead, we just want to unit test different python functions in the FitMultiple class.
--  However, most of the important behavior we need to test requires access to an actual
--  Greenplum database... mostly, we want to make sure that the models hop around to the
--  right segments in the right order.  Therefore, the unit tests are here, as a part of
--  dev-check. we mock fit_transition() and some validation functions in FitMultiple, but
--  do NOT mock plpy, since most of the code we want to test is embedded SQL and needs to
--  get through to gpdb. We also want to mock the number of segments, so we can test what
--  the model hopping behavior will be for a large cluster, even though dev-check should be
--  able to run on a single dev host.

\i m4_regexp(MODULE_PATHNAME,
             <!\(.*\)libmadlib\.so!>,
            <!\1../../modules/deep_learning/test/madlib_keras_iris.setup.sql_in!>
)

-- Mock version() function to convince the InputValidator this is the real madlib schema
CREATE OR REPLACE FUNCTION madlib_installcheck_deep_learning.version() RETURNS VARCHAR AS
$$
    SELECT MADLIB_SCHEMA.version();
$$ LANGUAGE sql IMMUTABLE;

-- Call this first to initialize the FitMultiple object, before anything else happens.
-- Pass a real mst table and source table, rest of FitMultipleModel() constructor params
--  are filled in.  The can be overriden later, before test functions are called, if necessary.
CREATE OR REPLACE FUNCTION init_fit_mult(
    source_table            VARCHAR,
    model_selection_table   VARCHAR
) RETURNS VOID AS
$$
    import sys
    from mock import Mock, patch

    PythonFunctionBodyOnlyNoSchema(deep_learning,madlib_keras_fit_multiple_model)
    schema_madlib = 'madlib_installcheck_deep_learning'

    GD['fit_mult'] = madlib_keras_fit_multiple_model.FitMultipleModel(
        schema_madlib,
        source_table,
        'orig_model_out',
        model_selection_table,
        1
    )
    
$$ LANGUAGE plpythonu VOLATILE
m4_ifdef(<!__HAS_FUNCTION_PROPERTIES__!>, MODIFIES SQL DATA);

CREATE OR REPLACE FUNCTION test_init_schedule(
    schedule_table VARCHAR
) RETURNS BOOLEAN AS
$$
    fit_mult = GD['fit_mult']
    fit_mult.schedule_tbl = schedule_table

    if fit_mult.init_schedule_tbl():
        err_msg = None
    else:
        err_msg = 'FitMultiple.init_schedule_tbl() returned False'

    return err_msg
$$ LANGUAGE plpythonu VOLATILE
m4_ifdef(`__HAS_FUNCTION_PROPERTIES__',MODIFIES SQL DATA);

CREATE OR REPLACE FUNCTION test_rotate_schedule(
    schedule_table          VARCHAR
) RETURNS VOID AS
$$
    fit_mult = GD['fit_mult']

    if fit_mult.schedule_tbl != schedule_table:
        fit_mult.init_schedule_tbl()

    fit_mult.rotate_schedule_tbl()

$$ LANGUAGE plpythonu VOLATILE
m4_ifdef(`__HAS_FUNCTION_PROPERTIES__',MODIFIES SQL DATA);

-- Mock fit_transition function, for testing
--  madlib_keras_fit_multiple_model() python code
CREATE OR REPLACE FUNCTION madlib_installcheck_deep_learning.fit_transition_multiple_model(
    dependent_var               BYTEA,
    independent_var             BYTEA,
    dependent_var_shape         INTEGER[],
    independent_var_shape       INTEGER[],
    model_architecture          TEXT,
    compile_params              TEXT,
    fit_params                  TEXT,
    dist_key                    INTEGER,
    dist_key_mapping            INTEGER[],
    current_seg_id              INTEGER,
    segments_per_host           INTEGER,
    images_per_seg              INTEGER[],
    accessible_gpus_for_seg     INTEGER[],
    serialized_weights          BYTEA,
    is_final_training_call      BOOLEAN,
    use_caching                 BOOLEAN,
    custom_function_map         BYTEA
) RETURNS BYTEA AS
$$
    param_keys = [ 'compile_params', 'accessible_gpus_for_seg', 'dependent_var_shape', 'dist_key_mapping',
                   'current_seg_id', 'segments_per_host', 'custom_function_map', 'is_final_training_call',
                   'dist_key', 'serialized_weights', 'images_per_seg', 'model_architecture', 'fit_params',
                   'independent_var_shape', 'use_caching' ]

    num_calls = 0
    if 'transition_function_params' in GD:
        if dist_key in GD['transition_function_params']:
            if not 'reset' in GD['transition_function_params'][dist_key]:
                num_calls = GD['transition_function_params'][dist_key]['num_calls']
    num_calls += 1
    plpy.info("num_calls={} for dist_key={} seg_id={}".format(num_calls, dist_key, current_seg_id))
    plpy.info("images_per_seg={}, independent_var_shape for dist_key={} seg_id={}".format(images_per_seg, independent_var_shape, dist_key, current_seg_id))

    g = globals()
    params = dict()

    for k in param_keys:
        params[k] = g[k]

    if dependent_var:
        params['len_dependent_var'] = len(dependent_var)
    else:
        params['len_dependent_var'] = 0
    if independent_var:
        params['len_independent_var'] = len(independent_var)
    else:
        params['len_dependent_var'] = 0

    params['num_calls'] = num_calls

    if not 'transition_function_params' in GD:
        GD['transition_function_params'] = dict()
    GD['transition_function_params'][dist_key] = params

    # compute "logical" seg_id, skipping segments with no data
    #   ( current_seg_id is the "physical" seg_id )
    seg_id = dist_key_mapping.index( dist_key )

    if dependent_var_shape[1] * num_calls < images_per_seg [ seg_id ]:
        return None
    else:
        GD['transition_function_params'][dist_key]['reset'] = True
        return serialized_weights
$$ LANGUAGE plpythonu VOLATILE;

CREATE OR REPLACE FUNCTION validate_transition_function_params(
    current_seg_id                       INTEGER,
    images_per_seg                       INTEGER,
    expected_num_calls                   INTEGER,
    expected_dist_key                    INTEGER,
    expected_is_final_training_call      BOOLEAN,
    expected_dist_key_mapping            INTEGER[]
) RETURNS TEXT AS
$$
    err_msg = "transition function was not called on segment {}"

    if 'transition_function_params' not in GD:
        return err_msg.format(current_seg_id)
    elif expected_dist_key not in GD['transition_function_params']:
        return err_msg + " for __dist_key__ = {}".format(expected_dist_key)
    actual = GD['transition_function_params'][expected_dist_key]

    err_msg = """Incorrect value for is_final_training_call param passed to fit_transition_multiple_model:
       Actual={}, Expected={}"""

    plpy.info("tfp[{}].keys() = {}".format(expected_dist_key, GD['transition_function_params'][expected_dist_key]))

    if actual['current_seg_id'] != current_seg_id:
        return err_msg.format(
            actual['current_seg_id'],
            current_seg_id
        )
    elif actual['num_calls'] != expected_num_calls:
        return err_msg.format(
            actual['num_calls'],
            expected_num_calls
        )
    elif actual['is_final_training_call'] != expected_is_final_training_call:
        return err_msg.format(
            actual['is_final_training_call'],
            expected_is_final_training_call
        )
    elif actual['dist_key'] != expected_dist_key:
        return err_msg.format(
            actual['dist_key'],
            expected_dist_key
        )

    return 'PASS'  # actual params match expected params
$$ LANGUAGE plpythonu VOLATILE;

-- Helper to rotate an array of int's
CREATE OR REPLACE FUNCTION rotate_keys(
    keys    INTEGER[]
) RETURNS INTEGER[]
AS $$
   return keys[-1:] + keys[:-1]
$$ LANGUAGE plpythonu IMMUTABLE;

CREATE OR REPLACE FUNCTION reverse_rotate_keys(
    keys    INTEGER[]
) RETURNS INTEGER[]
AS $$
   return keys[1:] + keys[:1]
$$ LANGUAGE plpythonu IMMUTABLE;

CREATE OR REPLACE FUNCTION setup_model_tables(
    input_table TEXT,
    output_table TEXT
) RETURNS TEXT AS
$$ 
    fit_mult = GD['fit_mult']

    fit_mult.model_input_tbl = input_table
    fit_mult.model_output_tbl = output_table
    fit_mult.init_model_output_tbl()
$$ LANGUAGE plpythonu VOLATILE;

CREATE OR REPLACE FUNCTION test_run_training(
    source_table TEXT,
    hop INTEGER,
    is_very_first_hop BOOLEAN,
    is_final_training_call BOOLEAN
) RETURNS VOID AS
$$
    fit_mult = GD['fit_mult']

    fit_mult.source_tbl = source_table
    fit_mult.is_very_first_hop = is_very_first_hop
    fit_mult.is_final_training_call = is_final_training_call

    fit_mult.run_training(hop=hop, is_very_first_hop=is_very_first_hop)
    plpy.info('FitMultiple.run_training(hop={}, is_very_first_hop={}) returned successfully' \
            .format(hop, is_very_first_hop))

$$ LANGUAGE plpythonu VOLATILE
m4_ifdef(`__HAS_FUNCTION_PROPERTIES__',MODIFIES SQL DATA);

CREATE OR REPLACE FUNCTION validate_mst_key_order(output_tbl TEXT, expected_tbl TEXT)
RETURNS VOID AS
$$
DECLARE
    actual INTEGER[];
    expected INTEGER[];
BEGIN
    EXECUTE format(
        'SELECT ARRAY('
            'SELECT mst_key FROM %I '
                'ORDER BY __dist_key__)',
        output_tbl
    ) INTO actual;

    EXECUTE format(
        'SELECT mst_keys FROM %I', expected_tbl
    ) INTO expected;

    EXECUTE format(
        'SELECT ASSERT('
            '$1 = $2,'
            '%L || '
            '%L || $1::TEXT || '
            '%L || $2::TEXT'
        ')',
        'mst keys found in wrong order / wrong segments!',
        E'\nActual: ',
        E'\nExpected: '
    ) USING actual, expected;
    
END
$$ LANGUAGE PLpgSQL VOLATILE;

-- Create mst table
DROP TABLE IF EXISTS iris_mst_table, iris_mst_table_summary;
SELECT load_model_selection_table(
    'iris_model_arch',
    'iris_mst_table',
    ARRAY[1],
    ARRAY[
        $$loss='categorical_crossentropy',optimizer='Adam(lr=0.1)',metrics=['accuracy']$$,
        $$loss='categorical_crossentropy', optimizer='Adam(lr=0.01)',metrics=['accuracy']$$,
        $$loss='categorical_crossentropy',optimizer='Adam(lr=0.001)',metrics=['accuracy']$$
    ],
    ARRAY[
        $$batch_size=5,epochs=1$$,
        $$batch_size=10,epochs=1$$
    ]
);

-- Create FitMultiple object for running test functions
SELECT init_fit_mult('iris_data_15buf_packed', 'iris_mst_table');
DROP TABLE IF EXISTS model_input, model_output;

-- ====================================================================
-- ===========  Enough setup, now for the actual tests! ===============
-- ====================================================================

--=== Test init_schedule_tbl() ===--
DROP TABLE IF EXISTS current_schedule;
SELECT test_init_schedule('current_schedule');
SELECT assert(
    mst_key IS NOT NULL,
    'mst_keys in schedule table created by test_init_schedule() does not match keys in mst_table'
) FROM current_schedule FULL JOIN iris_mst_table USING (mst_key);

-- Save order of mst keys in schedule for tracking 
DROP TABLE IF EXISTS expected_order;
CREATE TABLE expected_order AS SELECT ARRAY(SELECT mst_key FROM current_schedule ORDER BY __dist_key__) mst_keys;

SELECT mst_keys FROM expected_order;

--==== Test rotate_schedule() ====--
SELECT test_rotate_schedule('current_schedule');
UPDATE expected_order SET mst_keys=rotate_keys(mst_keys);
SELECT mst_keys FROM expected_order;
SELECT validate_mst_key_order('current_schedule', 'expected_order');
UPDATE expected_order SET mst_keys=reverse_rotate_keys(mst_keys);  -- Undo for later

m4_ifelse(m4_eval(__DBMS_VERSION_MAJOR__ >= 6),1,
<!  -- Rest of tests for gpdb 6+ only

SELECT setup_model_tables('model_input', 'model_output');
    UPDATE model_output -- Reduce size of model for faster tests
        SET ( model_weights, model_arch, compile_params, fit_params ) =
            ( mst_key::TEXT::BYTEA,
              ('{ "a" : ' || mst_key::TEXT || ' }' )::JSON,
              'c' || mst_key::TEXT,
              'f' || mst_key::TEXT );
  SELECT * FROM current_schedule; -- DEBUG
  SELECT * FROM model_output;  -- DEBUG
SELECT validate_mst_key_order('model_output', 'expected_order');

--=== Test very first hop of first iteration ===--
SELECT test_run_training('iris_data_15buf_packed', 0, True, False);

    -- mst_keys should not have moved
    SELECT validate_mst_key_order('model_output', 'expected_order');

--=== Test an ordinary hop (should re-create a new model_output table with rotated mst_keys) ===--
SELECT test_run_training('iris_data_15buf_packed', 1, False, False);

    -- check that mst keys rotated onto correct segments
    UPDATE expected_order SET mst_keys=rotate_keys(mst_keys);
    SELECT validate_mst_key_order('model_output', 'expected_order');

--===  Test first hop of another iteration ===--
SELECT test_run_training('iris_data_15buf_packed', 0, False, False);

    -- mst keys should not have not moved this time
    SELECT validate_mst_key_order('model_output', 'expected_order');

--=== Test final training hop ===--
SELECT test_run_training('iris_data_15buf_packed', 8, False, True);

    -- check that mst keys rotated onto correct segments
    UPDATE expected_order SET mst_keys=rotate_keys(mst_keys);
    SELECT validate_mst_key_order('model_output', 'expected_order');

--=== TODO:  Test same 6 msts, fake # segs changed from 3 to 6 (= # msts) and 7 (> # msts) ===-

-- Test a final training hop
UPDATE model_output SET (mst_key, model_weights)=(NULL, NULL) WHERE mst_key=3;
SELECT test_run_training('iris_data_15buf_packed', 2, False, True);

DROP TABLE IF EXISTS validate_params_results;
CREATE TABLE validate_params_results AS
    SELECT validate_transition_function_params(
        gp_segment_id,
        [10, 10, 10],
        5,            -- num_calls
        __dist_key__,
        True,         -- expected is_final_training_call
        ARRAY(  -- expected dist_key_mapping
            SELECT __dist_key__
            FROM iris_data_15buf_packed
            GROUP BY __dist_key__, gp_segment_id
            ORDER BY gp_segment_id
        )
    ) AS res
FROM iris_data_15buf_packed;

-- Test a final training hop for # msts < # segs with caching disabled
--        - check that fit_transition called only on segments with
--        - non-NULL weights
-- Test a final training hop for # msts < # segs with caching enabled
-- TODO:  - set use_caching=True
--        - check that fit_transition is called on ALL segments, even
--          if they have NULL weights.

SELECT assert(res = 'PASS', res) FROM validate_params_results;

     !> )  -- m4_endif DBMS_VERSION_MAJOR >= 6
>>> )  -- m4_endif postgres

